#!/usr/bin/env python3
'''
Implementation of the Sarah2 cipher from http://laser-calcium.glitch.me/

Sarah2 is claimed to be a "strong pen-and-paper cipher".
'''
import random
import math

ALPHABET = '_abcdefghijklmnopqrstuvwxyz'
INT_TO_PAIR = [a + b for a in ALPHABET for b in ALPHABET]
PAIR_TO_INT = {j: i for i, j in enumerate(INT_TO_PAIR)}

class Sarah2Cipher:
    def __init__(self, key=None):
        ''' Create a cipher instance.

        If key=None, generates a new random key.
        '''

        if key is None:
            key = [a + b for a in ALPHABET for b in ALPHABET]
            # shuffle with urandom - should be fairly secure
            random.SystemRandom().shuffle(key)

        self.key = key

    def _encrypt_round(self, msg, final):
        out = []
        for i in range(0, len(msg), 2):
            out.append(self.key[PAIR_TO_INT[msg[i:i+2]]])
        out = ''.join(out)
        if not final:
            out = out[::2] + out[1::2]
        return out

    def encrypt(self, msg, rounds):
        if len(msg) % 2 == 1:
            msg += '_'

        if rounds in (self.EASY, self.MEDIUM, self.HARD):
            rounds = self.num_rounds(msg, rounds)

        for i in range(rounds):
            msg = self._encrypt_round(msg, final=(i == rounds - 1))
        return msg

    def _decrypt_round(self, msg, initial):
        if not initial:
            mid = len(msg) // 2
            msg = ''.join(a + b for a, b in zip(msg[:mid], msg[mid:]))

        out = []
        for i in range(0, len(msg), 2):
            out.append(INT_TO_PAIR[self.key.index(msg[i:i+2])])
        out = ''.join(out)
        return out

    def decrypt(self, msg, rounds):
        if len(msg) % 2 == 1:
            raise ValueError("message must be of even length")

        if rounds in (self.EASY, self.MEDIUM, self.HARD):
            rounds = self.num_rounds(msg, rounds)

        for i in range(rounds):
            msg = self._decrypt_round(msg, initial=(i == 0))
        return msg

    # Easy number of rounds: log2(n)
    EASY = 'easy'

    # Medium number of rounds: log2(n)+2
    MEDIUM = 'medium'

    # Hard number of rounds: log2(n)*2
    HARD = 'hard'

    @classmethod
    def num_rounds(cls, x, mode):
        # allow integer or string arguments
        if not isinstance(x, int):
            x = len(x)

        n = int(math.ceil(math.log(x, 2)))

        if mode == cls.EASY:
            return n
        elif mode == cls.MEDIUM:
            return n+2
        elif mode == cls.HARD:
            return n*2
        else:
            raise ValueError("bad mode %s" % cls.mode)

if __name__ == '__main__':
    # a random key generated by the website
    key = [
'kz', 'gz', 'qf', 'lj', 'yv', 'bz', 'ph', 'fd', 'hg', 'ye', 'qq', 'ze', 'fo', 'ci', 'rh', 'kx', 'lz', 'ec', 'fk', 'mm', 'yx', 'mc', 'is', 'hm', 'ef', 'aj', 'gk',
'po', 'ii', 'fw', 'vn', 'am', 'hi', 'bt', 'yf', 'eg', 'tr', 'vt', 'tu', 'xt', '_s', 'oj', 'ny', 'zz', 'ua', 'os', 'mn', 'fm', 'zx', 'qh', '_d', 'qe', 'ss', 'en',
'yj', 'si', 'hy', 'vm', 'gq', 'gd', 'kc', 'px', 'jd', 'ka', 'yt', 'ck', 'lf', 'cw', 'tw', 'qb', 'tx', 'rs', 'zn', 'yo', 'gb', 'ap', 'js', 'nv', 'tv', 'fe', 'fc',
'xi', 'nx', 'xf', 'au', 'it', 'wo', 'bm', '_h', 'mj', 'qg', 'lu', 'eq', 'ao', 'ed', 'vk', 'pm', 'lp', 'cm', 'cu', 'nz', 'bf', 'vg', 'zu', 'uz', 'av', 'by', 'bl',
'yl', 'xo', 'ig', 'lw', 'wx', 'ts', 'nr', 'ge', 'eb', 'fs', 'pr', 'dc', 'g_', 'ij', 'td', 'wa', 'ad', 'eu', 'gj', 'fz', 'dj', 'hp', 'xy', 'zi', 'eo', 'xq', 'ql',
'wy', 'pp', 'wq', 'qk', 'iy', 'ty', 'su', 'hv', 'es', 'gu', 'ar', 'kf', 'xv', 'sn', 'na', 'e_', 'cb', 'pt', 'so', 'ab', 'pk', 'pq', 'uo', 'xx', 'ak', 'cg', 'id',
'op', 'sd', 'qj', 'lt', 'tj', 'cl', 'hx', 'wh', 'cx', 'qp', 'cc', 'xp', 'ga', 'qa', 'io', 'bv', 'gy', 'ke', 'bb', 'mv', 'ym', 'nj', 'u_', 'rv', 'mh', 'zj', 'st',
'sc', 'mr', '_e', 'gx', 'ir', 'r_', 'hs', '_i', 'ft', 'fq', 'w_', 'f_', 'ee', 'sh', 'sp', 'qn', 'tc', 'oo', 'jl', 'ov', 'li', 'ro', 'bs', 'ot', 'pi', 'sx', 'bp',
'xe', 'mg', 'fh', 'ys', 'kq', 'ta', 'rc', '_a', 'ms', 'tm', 'ne', 'jv', 'ds', 'xw', 'xz', 'ni', 'xb', 'mk', 'tb', 'yz', 'on', 'xa', 'mq', 'uk', 'ya', 'xh', 'vs',
'qy', 'fb', 'ax', 'gh', 'dh', 'sq', 'iz', 'hj', 'uw', '_r', 'ek', 'rq', 'zq', 'bq', 'bd', 'md', 'db', 'yi', 'q_', 'zp', 'za', 'hr', 'vu', 'll', 'ng', 'fl', 'uh',
'mt', 'jt', 'sa', 'hq', 'xj', 'vy', '_c', 'ff', 'or', 'pd', 'ws', 'fu', 'uu', 'pg', 'a_', 'ln', 'cp', 'mb', 'hu', 'nm', 'ls', 'uy', 'ku', 'gg', 'fi', 'hl', 'ik',
'yy', 'fj', 'iw', 'pw', 'ju', 'oy', 'yk', 'at', 'rz', 'bx', 'rw', 'ky', 'hh', 'dn', 'vf', 'fn', 'rd', 'pb', 'ww', 'ol', 'kk', 'oa', 'zs', '_t', 'yp', 'iq', 'xl',
'wt', 'oi', 'tg', 'qr', 'bj', 'kg', 'ba', 'lg', '_z', 'ev', 'wd', 'tf', 'ha', 'km', 'oz', 'sy', 'te', 'j_', 'mi', 'vl', 'nb', 'dl', 'lo', 'jz', 'em', 'hc', 'mf',
'eh', '_f', '_x', 'je', 'fg', 'mz', 'hz', 'zf', 'di', 'sj', 'pn', 'up', 'dy', 'vp', 'tk', 'ei', 'wc', 'yr', 'cf', 'y_', 'wv', 'xk', 'qv', '_n', 'wm', 'ug', 'af',
'_q', 'cr', 'as', 'iv', 'gi', 'xr', 'tn', 'ez', 'lm', 'wp', 'gr', 'jy', 'yd', '_j', 'rg', 'i_', 'ca', 'mx', 'da', 'uq', 'ch', 'mo', 'cv', 'gp', 'ho', 's_', 'lh',
'vd', 'yh', 've', 'yc', 'nh', 'ma', 'bo', 'kv', 'uc', 'le', 'gn', 'wk', 'ti', 'ko', 'yu', 'ow', 'oc', 'zg', '_w', 'vo', 'zw', 'ns', 'l_', 'wf', 'fx', 'la', 'jr',
'rb', 'nn', '__', 'b_', 'cq', 'dg', 'ob', 'vb', 'us', 'jq', 'fa', 'kw', 'gw', 'lx', 'wu', 'wb', 'il', 'gf', '_g', 'xs', 'du', 'fy', 'hk', 'ul', 'c_', 'dv', 'rm',
'nw', 'ps', 'yb', 'rp', 'ac', 'nl', 'zc', 'rx', 'jc', 'qc', 'vc', 'vq', 'ui', 'ht', 'qo', 'to', 'ey', 'gv', 'np', 'z_', 'aq', 'rj', 'nq', 'pj', 'sg', 'pu', 'mp',
'jo', 'k_', 'gs', 'wn', 'kd', 'vw', 'kn', 'h_', 'jg', '_y', 'qx', 'py', '_l', 'wl', 'tt', 'ou', 'dk', 'tz', 'of', 'wg', 'pz', 'ld', 'kb', 'cn', 'lk', 'qm', 'rf',
'ox', 'ae', 'ie', 'dd', 'gc', 'he', 't_', 'ib', 'no', 'go', 'lq', 'ry', 'vr', 'cz', 'de', 'xd', 'az', 'ip', 'ic', 'hb', '_p', 'm_', 'rt', 'wr', 'xg', 'zt', 'xm',
'zm', 'jh', 'qs', 'vj', 'dp', 're', 'br', 'rr', 'ix', 'vi', 'cd', 'pv', 'sm', 'qi', 'un', 'ks', 'jk', 'ra', 'kh', 'ia', 'dr', 'zr', 'qd', 'kt', 'qz', 'nc', 'bu',
'sl', 'lr', 'bh', 'ej', 'xu', 'pc', 'oe', 'nf', 'bi', 'do', '_o', 'jn', 'ud', 'qu', 'bn', 'lv', 'ah', 'hw', 'if', 'be', 'ub', '_b', 'lb', 'jj', 'jf', 'zk', 'pl',
'jb', 'ag', 'tq', 'lc', 'iu', 'pe', 'se', 'dz', 'zb', 'gt', 'fp', 'og', 'zl', 'co', 'ok', 'sr', 'ja', 'kr', 'ay', 'kj', 'sv', 'wj', 'od', 'ea', 'um', 'ih', 'kl',
'x_', 'p_', 'ru', 'ut', 'uv', 'nk', 'ux', 'mw', 'o_', 'ce', 'zd', 'ue', 'dw', 'er', 'hd', 'pa', 'v_', 'bc', 'in', 'rl', 'wi', 'zo', 'ai', 'yn', 'ji', 'yg', 'my',
'qw', 'zh', 'el', 'gm', 'rn', 'fv', 'hn', 'jw', 'im', '_k', 'nd', 'ct', 'ly', 'uf', 'fr', 'bg', 'nt', 'al', 'vx', 'bw', 'bk', 'd_', 'oq', 'ep', 'n_', 'dt', 'jx',
'aa', 'ew', 'dq', 'vz', 'aw', 'me', 'tp', 'xc', 'dx', 'kp', 'yq', 'vh', 'ri', 'cy', 'qt', 'an', 'va', 'gl', 'df', 'sz', 'uj', 'sk', '_u', 'zy', 'mu', 'vv', '_m',
'ur', 'sf', 'ki', 'jp', 'wz', 'pf', 'zv', 'nu', 'xn', 'hf', 'sb', 'et', 'rk', 'jm', '_v', 'th', 'oh', 'cj', 'ex', 'ml', 'om', 'yw', 'dm', 'sw', 'cs', 'tl', 'we',
]

    # test vectors generated by the website
    cipher = Sarah2Cipher(key)

    print(cipher.encrypt('abcd', 1))
    print(cipher.encrypt('abcd', 2))
    print(cipher.encrypt('abcd', 3))
    print(cipher.encrypt('abcd', 4))

    pt = 'attack_at_dawn'
    assert Sarah2Cipher.num_rounds(pt, Sarah2Cipher.EASY)   == 4
    assert Sarah2Cipher.num_rounds(pt, Sarah2Cipher.MEDIUM) == 6
    assert Sarah2Cipher.num_rounds(pt, Sarah2Cipher.HARD)   == 8
    assert cipher.encrypt(pt, Sarah2Cipher.EASY)   == '_fjqoaprokfpgu'
    assert cipher.encrypt(pt, Sarah2Cipher.MEDIUM) == 'tojdilkepmhbvv'
    assert cipher.encrypt(pt, Sarah2Cipher.HARD)   == 'cubeovxjz_jouq'
    assert cipher.decrypt('_fjqoaprokfpgu', Sarah2Cipher.EASY)   == pt
    assert cipher.decrypt('tojdilkepmhbvv', Sarah2Cipher.MEDIUM) == pt
    assert cipher.decrypt('cubeovxjz_jouq', Sarah2Cipher.HARD)   == pt

    pt = 'this_is_a_test_vector_for_python_implementation_'
    assert Sarah2Cipher.num_rounds(pt, Sarah2Cipher.EASY)   == 6
    assert Sarah2Cipher.num_rounds(pt, Sarah2Cipher.MEDIUM) == 8
    assert Sarah2Cipher.num_rounds(pt, Sarah2Cipher.HARD)   == 12
    assert cipher.encrypt(pt, Sarah2Cipher.EASY)   == 'efmn_kdvuadequammnnpgn_luenlbrdeldkbxhomwjuesynp'
    assert cipher.encrypt(pt, Sarah2Cipher.MEDIUM) == 'ztntiapxqswzuhmkbyoqngodcvbepwmxwhmavohrameaotew'
    assert cipher.encrypt(pt, Sarah2Cipher.HARD)   == 'd_rgtmjpjvrkiecsduwbfbmkqgmrrnqmicsdcghraeifgu_y'
    assert cipher.decrypt('efmn_kdvuadequammnnpgn_luenlbrdeldkbxhomwjuesynp', Sarah2Cipher.EASY)   == pt
    assert cipher.decrypt('ztntiapxqswzuhmkbyoqngodcvbepwmxwhmavohrameaotew', Sarah2Cipher.MEDIUM) == pt
    assert cipher.decrypt('d_rgtmjpjvrkiecsduwbfbmkqgmrrnqmicsdcghraeifgu_y', Sarah2Cipher.HARD)   == pt
